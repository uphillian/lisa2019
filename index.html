<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">
    <link rel="stylesheet" href="css/custom.css">

    <!-- Google font -->
    <link href="https://fonts.googleapis.com/css?family=Big+Shoulders+Display&display=swap" rel="stylesheet">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <style>
      body:after {
        content: "http://bit.ly/33NpWEk " url(./lisa50.png);
        position: fixed;
        bottom: 3.5em;
        right: 3.5em;
        color: white;
        box-shadow: 5px 5px 10px #000; }
     </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <section data-background-image='mu_white200.png' data-background-size=10% data-background-position="bottom 20px right 20px">
            <h1>Linux Systems Troubleshooting</h1><h2>Thomas Uphill</h2><h3>thomas@uphillian.com</h3>
          </section>
          <section>
            <h1>Me</h1>
            <a href="https://www.google.com/search?q=Thomas+Uphill"><img src="./author.png"></a>
            <h2>consulting@uphillian.com</h2>
          </section>
          <section>
            <h1>Resources</h1>
            <h4><a href="https://github.com/uphillian/lisa2019">https://github.com/uphillian/lisa2019</a></h4>
            <h4><a href="https://github.com/uphillian/troubleshootinglinux">https://github.com/uphillian/troubleshootinglinux</a></h4>
          </section>
        </section>

        <section>
          <section><h1>A story</h1><img height="50%" src="./rainbow_unicorn200.png" border="0">
            <aside class="notes">
             A dual homed system, two IP addresses on the system.
             A certain DB product is advertise itself to other members of its "lattice" using address A.
             Backup product is using address A as well.

             The DB product should actually be using address B.
             No way to configure the DB product to use a specific address.

             so begins the investigation… what's going on here.
             </aside>
          </section>

          <section>
            <span class="fragment fade-in">DB
              <span class="fragment fade-in">⇨</span>
              <span class="fragment fade-in">gethostname</span>
              <br><span class="fragment fade-in"><img valign="middle" height=10% src="./rainbow_unicorn200_right.png" border=0></span>
            </span>
            <p>
            <span class="fragment fade-in">Backup
              <span class="fragment fade-in">⇨</span>
              <span class="fragment fade-in">gethostname</span>
              <br><span class="fragment fade-in"><img valign="middle" height=10% src="./rainbow_unicorn200_right.png" border=0></span>
            </span>
          </section>

          <section>
            <span class="fade-in">DB
              <span class="fade-in">⇨</span>
              <span class="fade-in">gethostname</span>
              <br><span class="fragment fade-in"><img valign="middle" height=10% src="./rainbow_unicorn200_right.png" border=0></span>
            </span>
            <p>
            <span class="fade-in">Backup
              <span class="fade-in">⇨</span>
              <span class="fade-in">gethostname</span>
              <br><span class="fragment fade-in"><img valign="middle" height=10% src="./rainbow_unicorn200_left.png" border=0></span>
            </span>
          </section>

          <section><h1>Where to start?</h1>
            <aside class="notes">for the purposes of this talk, I've replaced the backup software with a program written in C which is functionally equivalent to the original backup program.
            We'll call it getip.
            getip returns the primary ip address of the machine on which it is running.
            show gethostname in use. there are other examples but tar is good enough.
            show the below on a host without debuginfo, and one with it.
            [root@localhost bin]# ltrace -e gethostname tar cf phoenix:foo.tar /etc/hosts
            </aside>
           </section>

           <section>
             <h1>ltrace</h1>
             <span class="fragment fade-in">
               <span class="fragment fade-out">Why?</span>
               <span class="fragment fade-in">Because UNIX is old</span>
             </span>
           </section>

           <section>
             <aside class="notes">Linux is a clone of UNIX, UNIX is a clone of MULTICS
               The important thing to remember is that it was developed on a pdp-7
               A pdp-7 had a standard memory of just under 10kb.  The max was 144kb.
               We are talking a very tight space to work. this is the time of punch cards, terminals are still new.
               They had to be stingy with space, they reused everything they could and came up with the model we use today.
               And there was a method to the madness, KISS, keep it simple stupid
             </aside>
             <span>
               <span class="fragment fade-in"><img src="./pdp7.png"><br></span>
               <span class="fragment fade-in"><img src="./tape.png"><br></span>
             <span class="fragment fade-in"><h1>Love Ken</h1></span>
               <span class="fragment fade-in"><h1>KISS</h1></span>
             </span>
           </section>
        </section>
        <section>
          <section>
            <h1>How it all works</h1>
          </section>
          <section>
            <aside class="notes">
              you can have too much detail, so this is going to be a very simplistic view of the system.
              we will start with the kernel, the kernel needs to talk to hardware
              this is done with drivers, many drivers are in the form of kernel modules
              the modules are just bits of code that can be loaded and unloaded as needed.
              At the top you have the applications, when an application needs to do something at a system level,
              it needs to ask the kernel, it asks via system calls

            </aside>
            <h1>Kernel</h1>
            <table>
              <tr>
                <td align=center>
                  <span class=fragment data-fragment-index=2>application</span>
                </td>
                <td bgcolor=lightsteelblue>
                  <span class=fragment data-fragment-index=10>user</span>
                </td>
              </tr>
              <tr>
                <td bgcolor=lavender align=center>
                  <span class=fragment data-fragment-index=4><font color=darkred>⇳ system calls ⇳</font></span>
                </td>
                <td bgcolor=white>
                </td>
              </tr>
              <tr>
                <td align=center>
                  <img height=100 src="./tux.png">
                </td>
                <td bgcolor=lavender rowspan=3>
                  <span class=fragment data-fragment-index=11>kernel</span>
                </td>
              </tr>
              <tr height=25>
                <td bgcolor=lavender align=center>
                  <span class="fragment fade-in" data-fragment-index=3><font color=darkred>⇳ driver/module ⇳</font></span>
                </td>
              </tr>
              <tr>
                <td align=center>
                  <span class="fragment fade-in" data-fragment-index=1>hardware</span>
                </td>
              </tr>
            </span>
            </table>
          </section>

          <section>
            <h1>System Calls</h1>
            <aside class="notes">
              when designed, there were 34 system calls
              they are still there today, there are a few hundred now
              the original 34 include things like open, close, fork, connect, exit, chown, chmod, flock, malloc, write
            </aside>
          </section>

          <section>
            <aside class="notes">
              man syscalls
              man glibc
              man intro
            </aside>
            <h1>Documentation</h1>
            <img class="fragment fade-in" src="./morpheus.jpg">
            <h2 class="fragment fade-in">man syscalls <span class="fragment">&rArr;</span></h2>
          </section>

          <section>
            <aside class="notes">
              again, not interested in writing code more than once, they created libraries that could do perform the calls on behalf
              of user apps.  the shared libraries were the C-library.
              GNU reimplemented in a Free as in Freedom way, created the GNU C-library.
            </aside>
            <h1>Shared Libraries</h1>
            <span class="fragment fade-in"><h2>glibc</h2>
              <span class="fragment fade-in"><h2>libc.so</h2></span>
            </span>
          </section>

          <section>
            <h1>ltrace</h1>
            <h2 class="fragment">...finally</h2>
          </section>

          <section>
            <aside class="notes">
              each line is a library call, each one of these has a man page that describes the input, output and return values.
              try man rindex on your own laptop
              ltrace is showing the library calls, strace only shows the syscalls, but you can get both with ltrace -S
            </aside>
            <pre class="stretch"><code class="bash">
[root@localhost ~]# ltrace hostname
_libc_start_main(0x401230, 1, 0x7ffd4a91dd48, 0x401ea0 &lt;unfinished ...&gt;
rindex("hostname", '/')                                          = nil
strcmp("hostname", "domainname")                                 = 4
strcmp("hostname", "ypdomainname")                               = -17
strcmp("hostname", "nisdomainname")                              = -6
getopt_long(1, 0x7ffd4a91dd48, "aAdfbF:h?iIsVy", 0x4028a0, nil)  = -1
__errno_location()                                               = 0x7fefda8a86b0
malloc(128)                                                      = 0x1a0a010
gethostname("localhost.localdomain", 128)                        = 0
memchr("localhost.localdomain", '\0', 128)                       = 0x1a0a025
puts("localhost.localdomain"localhost.localdomain)               = 22
+++ exited (status 0) +++</code></pre>
          </section>
          <section>
            <aside class="notes">
              with -S we see all the syscalls, the interesting thing is:
              open@SYS("/etc/ld.so.cache", 524288, 01)                                                                   = 3
            </aside>
            <pre class="stretch"><code class="bash">
[root@localhost ~]# ltrace -S hostname
brk@SYS(nil)                                                                                               = 0x2386000
mmap@SYS(nil, 4096, 3, 34, -1, 0)                                                                          = 0x7f28906de000
access@SYS("/etc/ld.so.preload", 04)                                                                       = -2
open@SYS("/etc/ld.so.cache", 524288, 01)                                                                   = 3
fstat@SYS(3, 0x7ffcfb5c0830)                                                                               = 0
mmap@SYS(nil, 22425, 1, 2, 3, 0)                                                                           = 0x7f28906d8000
close@SYS(3)                                                                                               = 0
open@SYS("/lib64/libnsl.so.1", 524288, 022033410520)                                                       = 3
read@SYS(3, "\177ELF\002\001\001", 832)                                                                    = 832
fstat@SYS(3, 0x7ffcfb5c0890)                                                                               = 0
mmap@SYS(nil, 2202232, 5, 2050, 3, 0)                                                                      = 0x7f28902a4000
mprotect@SYS(0x7f28902ba000, 2097152, 0)                                                                   = 0
mmap@SYS(0x7f28904ba000, 8192, 3, 2066, 3, 90112)                                                          = 0x7f28904ba000
mmap@SYS(0x7f28904bc000, 6776, 3, 50, -1, 0)                                                               = 0x7f28904bc000
close@SYS(3)                                                                                               = 0
open@SYS("/lib64/libc.so.6", 524288, 022033410520)                                                         = 3
read@SYS(3, "\177ELF\002\001\001\003", 832)                                                                = 832
fstat@SYS(3, 0x7ffcfb5c0860)                                                                               = 0
mmap@SYS(nil, 3981792, 5, 2050, 3, 0)                                                                      = 0x7f288fed7000
mprotect@SYS(0x7f2890099000, 2097152, 0)                                                                   = 0
mmap@SYS(0x7f2890299000, 24576, 3, 2066, 3, 1843200)                                                       = 0x7f2890299000
mmap@SYS(0x7f289029f000, 16864, 3, 50, -1, 0)                                                              = 0x7f289029f000
close@SYS(3)                                                                                               = 0
mmap@SYS(nil, 4096, 3, 34, -1, 0)                                                                          = 0x7f28906d7000
mmap@SYS(nil, 8192, 3, 34, -1, 0)                                                                          = 0x7f28906d5000
arch_prctl@SYS(4098, 0x7f28906d5740, 0x7f28906d6050, 34)                                                   = 0
mprotect@SYS(0x7f2890299000, 16384, 1)                                                                     = 0
mprotect@SYS(0x7f28904ba000, 4096, 1)                                                                      = 0
mprotect@SYS(0x602000, 4096, 1)                                                                            = 0
mprotect@SYS(0x7f28906df000, 4096, 1)                                                                      = 0
munmap@SYS(0x7f28906d8000, 22425)                                                                          = 0
__libc_start_main(0x401230, 1, 0x7ffcfb5c21e8, 0x401ea0 &lt;unfinished ...&gt;
rindex("hostname", '/')                                                                                    = nil
strcmp("hostname", "domainname")                                                                           = 4
strcmp("hostname", "ypdomainname")                                                                         = -17
strcmp("hostname", "nisdomainname")                                                                        = -6
getopt_long(1, 0x7ffcfb5c21e8, "aAdfbF:h?iIsVy", 0x4028a0, nil)                                            = -1
__errno_location()                                                                                         = 0x7f28906d56b0
malloc(128 &lt;unfinished ...&gt;
brk@SYS(nil)                                                                                               = 0x2386000
brk@SYS(0x23a7000)                                                                                         = 0x23a7000
brk@SYS(nil)                                                                                               = 0x23a7000
&lt; malloc resumed&gt; )                                                                                     = 0x2386010
gethostname( &lt;unfinished ...&gt;
uname@SYS(0x7ffcfb5c1e40)                                                                                  = 0
&lt; gethostname resumed&gt; "localhost.localdomain", 128)                                                    = 0
memchr("localhost.localdomain", '\0', 128)                                                                 = 0x2386025
puts("localhost.localdomain" &lt;unfinished ...&gt;
fstat@SYS(1, 0x7ffcfb5c1ec0)                                                                               = 0
mmap@SYS(nil, 4096, 3, 34, -1, 0)                                                                          = 0x7f28906dd000
write@SYS(1, "localhost.localdomain\n", 22localhost.localdomain
)                                                                = 22
&lt; puts resumed&gt; )                                                                                       = 22
exit_group@SYS(0 &lt;no return ...&gt;
+++ exited (status 0) +++
            </code></pre>
          </section>

          <section>
            <pre class="stretch"><code class="bash">
# file /bin/hostname
/bin/hostname: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c2b88b145e890709f0a93fdab448bfc40d10eb18, stripped</code></pre>
          </section>

          <section>
            <img src="elf.png" width=50%>
          </section>
          <section>
            <h1>Executable</h1>
            and
            <h1>Linkable</h1>
            <h1>Format</h1>
          </section>

          <section>
            <aside class="notes">
              What do we mean by linkable? Objects are linkable, you can link to other shared libraries.
              What's in charge of that? the linker.
            </aside>
            <h1>Linker</h1>
            <h2>ld.so</h2>
            <h2>/etc/ld.so.conf</h2>
            <h2>/lib64/ld-linux-x86_64.so.2</h2>
            <h1>man ld.so</h1>
          </section>

          <section>
            <aside class="notes">
              ELF contains information about what libraries are needed by the executable.
              show objdump, ldd all that fun
            </aside>
            <pre class="stretch"><code class="bash">
# ldd /bin/hostname
    linux-vdso.so.1 =>  (0x00007ffcda7dd000)
    libnsl.so.1 => /lib64/libnsl.so.1 (0x00007f43c4f06000)
    libc.so.6 => /lib64/libc.so.6 (0x00007f43c4b39000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f43c5120000)
# objdump -R /bin/hostname

/bin/hostname:     file format elf64-x86-64

DYNAMIC RELOCATION RECORDS
OFFSET           TYPE              VALUE
...
0000000000603140 R_X86_64_JUMP_SLOT  gethostname@GLIBC_2.2.5
# man ld.so</code></pre>
          </section>

          <section>
            <aside class="notes">
              LD_PRELOAD, how to preload stuff, so now we get into the meat...
              So now we know how to fix this, we can just intercept the call to gethostname
            </aside>
            <h1>LD_PRELOAD</h1>
            <p align=left>A list of additional, user-specified, ELF shared libraries to be loaded before all others.</p>
          </section>

          <section>
            <aside class="notes">
            </aside>
            <h1>LD_DEBUG</h1>
            <pre><code class="bash">
# LD_DEBUG=help /bin/true
Valid options for the LD_DEBUG environment variable are:

  libs        display library search paths
  reloc       display relocation processing
  files       display progress for input file
...
# LD_DEBUG=versions /bin/true
checking for version `GLIBC_2.3' in file /lib64/libc.so.6 [0] required by file /bin/true [0]
checking for version `GLIBC_2.3.4' in file /lib64/libc.so.6 [0] required by file /bin/true [0]
checking for version `GLIBC_2.14' in file /lib64/libc.so.6 [0] required by file /bin/true [0]
            </code></pre>
          </section>

        </section>
        <!-- end of background section, into solution -->

        <!-- terminal -->
        <section>
          <section>Terminal<br>
            <aside class="notes">
              First time through we show the man pages.
              Then we skip terminal and go to the "cannot escape slide"
              For solution, ap wrapper.cast
              For fd ap fd.cast
            </aside>
            <span id="terminal-iframe">
              <script>
                if ( window.location == window.parent.location ) {
                  document.getElementById('terminal-iframe').innerHTML = "<div><object type=text/html width=1024px height=600px class=ttyd data='http://127.0.0.1:8081'></object></div>";
                } else {
                  document.getElementById('terminal-iframe').innerHTML = "In Speaker View";
                }
              </script>
            </span>
          </section>
        </section>

        <section>
          <section>
            <aside class="notes">
              So to effectively debug a system, you will need to know some very basic C
              Don't try running away now, it's too late.
            </aside>
            <h1>You cannot escape</h1>
            <img src="prisoner.jpg"><br>
            <small class="caption">wikipedia.org</small>
          </section>

          <section>
            <aside class="notes">
              When we initially looked at the problem, I ran ltrace and worked out the important
              syscalls.  I've recreated those in a little application called getip.
              There are three syscalls
              gethostname
              gethostbyname
              inet_ntoa

              We could intervene with LD_PRELOAD to any one of these.
              The simplest is gethostname
            </aside>
            <h1>getip.c</h1>
            <pre class="stretch"><code class="bash">
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;

int main()
{
  char hostname[256];
  char *IPbuffer;
  struct hostent *hostStruct;
  int h;

  gethostname(hostname, sizeof(hostname));

  hostStruct = gethostbyname(hostname);

  if (hostStruct) {
    IPbuffer = inet_ntoa(*((struct in_addr*) hostStruct->h_addr_list[0]));
    printf("Using IP: %s\n", IPbuffer);
    return 0;
  } else {
    printf("Couldn't find IP for %s\n", hostname);
    return 1;
  }
}</code></pre>
          </section>

          <section>
            <aside class="notes">
              man gethostname shows everything we need to know about gethostname
            </aside>
            <h1>gethostname</h1>
            <pre class="stretch"><code class="bash">
#include &lt;unistd.h&gt;

int gethostname(char *name, size_t len);</code></pre>
          </section>

          <section>
            <aside class="notes">
              So all we need to go is make a string (an array of char) with the hostname we want and copy that into the name pointer location.
              the memory has already been allocated for us, so we don't have to worry about that either.
            </aside>
            <h1>gethostname_wrap.c</h1>
            <pre class="stretch"><code class="bash">
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int gethostname (char *name, size_t len) {
  char newname[] = "getip_hostname";
  int name_len = strlen(newname);
  memcpy(name,newname, name_len &lt; len ? name_len : len);
  return 0;
}</code></pre>
          </section>

          <section>
            <h1>Solution<br>&lArr;</h1>
            <aside class="notes">
              go back to terminal, show solution
              cd /vagrant
              ap wrapper.cast

              So now the two programs are working side by side compeltely oblivious to the fix.
              We didn't need to recompile anything and we get our paycheck.
              I hope this tale proves my point, that understanding how things work,
              makes solutions simple.
              So now a more about how things work
            </aside>
          </section>
        </section>

        <!-- more background info (high level -->
        <section>
          <section>
            <aside class="notes">
              This is one of the most pithy things I've heard in a movie.
              remember this while you are trying to troubleshoot a problem
            </aside>
            <p align=left>
              It's a machine, Skroeder.<br>
              It doesn't get pissed off.<br>
              It doesn't get happy,<br>
              it doesn't get sad,<br>
              it doesn't laugh at your jokes.<br>
              It just runs programs.<br>
            </p>
            <small class="caption">Short Circuit</small>
          </section>

          <section>
            <h1>More background</h1>
          </section>

          <section>
            <aside class="notes">
               when the machine turns on, it loads 512 bytes from sector 0 of the first disk.
               those 512 bytes have enough instructions to load the rest of the boot program.
               the boot program stars the kernel, the kernel by convention if process 0, it does not appear
               in the process list.
               This is all due to the way things used to work...when you turned on a PC, it only knew how to load sectore 0
            </aside>
            <h1>Booting process</h1>
            <table style="background: none">
              <tr>
                <td bgcolor=lightsteelblue class=fragment data-fragment-index=1>
                  BIOS
                </td>
                <td bgcolor=lightsteelblue class=fragment data-fragment-index=2>
                  Bootsector<br>0
                </td>
                <td bgcolor=lightsteelblue class=fragment data-fragment-index=3>
                  Bootloader<br>512
                </td>
              </tr>
              <tr>
                <td style="border: none"></td>
                <td style="border: none"></td>
                <td bgcolor=lavender class=fragment data-fragment-index=4><font color=darkred>Kernel<br>[0]<font></td>
                <td bgcolor=tan class=fragment data-fragment-index=5>init<br>1</td>
              </tr>
            </table>
          </section>

          <section>
            <aside class="notes">
              The kernel starts process 1, the kernel itself is process 0.
              Process 1 has to start the other processes, it does this with fork
              A process has a parent process id, ppid and a process id, pid.
              when processes fork, they are essentially duplicated, they inherit copies of the memory and environment of their parent.
              init/sysinit/systemd/upstart, whatever, it's job is to schedule all the userland processes.
              talk about pid 2, the pid's with [] around them kthreadd is 2.
            </aside>
            <h1>Processes</h1>
            <h2 class="fragment">fork</h2>
            <img class="fragment" src="./fork-small.jpg">

          </section>

          <section>
            <aside class="notes">
              ask them to run this themselves.
              Show the version in tutorial, go run that it's better.
              ap ps.cast
              psg
              psx
              psk

              Show how the only two who are children of the kernel are the init and the kthreadd
              show how everyone who is a child of 2 is a kernel process.
              ps aux |grep \\[ |sort |less


            </aside>
            <h1>parent/child</h1>
            <pre><code class="bash">
$ ps -eo "ppid pid stat cmd" |sort -n |less
$ psk
            </code></pre>
          </section>

          <section>
            <aside class="notes">
              The kernel allows you to see inside it's process tables and view data.
              It does this with fake filesystems.
              We'll talk about /proc the most in this talk but /sys is also worth looking around in.
            </aside>
            <h1>fake filesystems</h1>
            <img class="fragment" src="fake.png">
            <table>
              <tr>
                <td class="fragment">/proc</td>
                <td class="fragment">/sys</td>
              </tr>
            </table>
          </section>


          <section>
            <aside class="notes">
              No unix talk is complete without the phrase,
              everything is a file.
              The kernel displays process internals as files in /proc
              every process has at least 3 file handles / file descriptors.
              You can view the STDIN STDOUT and STDERR
              go backup and run ap fd.cast

            </aside>
            <h1>File Descriptors</h1>
            <h2 class="fragment">everything is a file...</h2>
            <table>
              <tr>
                <td class="fragment" data-fragment-index=5>STDIN</td>
                <td class="fragment" data-fragment-index=10>STDOUT</td>
                <td class="fragment" data-fragment-index=15>STDERR</td>
              </tr>
              <tr>
                <td class="fragment" data-fragment-index=5 align=center>0</td>
                <td class="fragment" data-fragment-index=10 align=center>1</td>
                <td class="fragment" data-fragment-index=15 align=center>2</td>
              </tr>
            </table>
          </section>

          <section>
            <aside class="notes">
              man fork
              fork is how unix creates new processes.
              double fork ensures that the calling process has no children
              the grandchild process has no parent. Orphaned processes are reaped by init (systemd)

            </aside>
            <h1>Processes</h1>
            <table>
              <tr>
                <td class="fragment" align=center>fork<br>
                  <img height=200px src="./fork-small.jpg">
                </td>
                <td class="fragment" align=center>double fork<br>
                  <div style="position:relative">
                  <span class="fragment fade-out" style="position:absolute;margin-left: auto; margin-right: auto; left:0; right: 0;"><img height=200px src="./doublefork.png"></span>
                  <span class="fragment fade-in" style="position:absolute;margin-left: auto; margin-right: auto; left:0; right: 0;"><img height=200px src="./beta-tree.png"></span>
                  </div>
                </td>
                <td class="fragment" align=center>zombie<br>
                  <img height=200px src="./zombie.png">
                </td>
              </tr>
            </table>

          </section>
          <section>
            fork
            <pre class="stretch"><code class="python">
#!/usr/bin/env python

import os
import time

pid = os.fork()
if pid == 0:
  print("Child")
  while True:
    time.sleep(10)
else:
  print("Parent, Child PID: %s" % pid)
  while True:
    time.sleep(10)
</code></pre>
          </section>
          <section>
            doublefork
            <pre class="stretch"><code class="python">
#!/usr/bin/env python

import os
import time

pid = os.fork()
if pid == 0:
  pid = os.fork()
  if pid == 0:
    print("I am the Grandchild(%s)\n" % os.getpid())
    while True:
      time.sleep(10)
  else:
    print("I am the Child(%s), Grandchild(%s)\n" % (os.getpid(),pid))
else:
  print("I am the Parent(%s), my Child(%s)\n" % (os.getpid(),pid))</code></pre>
          </section>

          <section>
            zombie
            <pre class="stretch"><code class="python">
#!/usr/bin/env python

import os
import sys
import time
import signal

def sigalrm(signum, frame):
  print("Received %d" % signum)

signal.signal(signal.SIGALRM, sigalrm)
pid = os.fork()
if pid == 0:
  print("Child exiting")
  sys.exit(0)
else:
  print("Parent PID %s, Child PID: %s\nWaiting for Signal" % (os.getpid(),pid) )
  signal.pause()
  os.wait()
  print("Zombie is gone\n") 
  sys.exit(0)
</code></pre>
          </section>

          <section>
            <aside class="notes">
              note that when we run doublefork, the grandchild's parent is now 1
              try it in your own session with systemd, you get your systemd as owner.
              you can't kill a zombie, they are already dead.
              check the status, it Z
            </aside>
            <h1>&rArr;</h1>
          </section>
        </section>
        <section>
          <section>Terminal<br>
            <aside class="notes">
              Show psx, then psk
              cat /proc/cmdline
              cd /proc/1
              cat cmdline
              cat environ
              cd /proc/$$
              cat environ
            </aside>
            <span id="processes-iframe">
              <script>
                if ( window.location == window.parent.location ) {
                  document.getElementById('processes-iframe').innerHTML = "<div><object type=text/html width=1024px height=600px class=ttyd data='http://127.0.0.1:8081'></object></div>";
                } else {
                  document.getElementById('processes-iframe').innerHTML = "In Speaker View";
                }
              </script>
            </span>
          </section>
        </section>
        <section>
          <section>
            <aside class="notes">
              filesystem filling, nothing there. talk about fd and open files.
              Two for the price of one.
              In one scenario, we were writing to a file that was deleted.
              In the second, we needed to get a running process to change the file it was writing to.
              in the example, we have a long running single threaded cobol job, we don't have the symbol table, but we don't care
              we get it to start writing onto the new filesystem and save the day.
              paycheck coming again.

              when doing gdb, remember to use " instead of ', you'll get the symbol problem.

              use gdb instead,
              gdb -p $pid
              $1 = 0
              (gdb) call open("/tmp/fd",0102,0666)
              $2 = 4
              (gdb) call dup2(4,3)
              k3 = 3
              (gdb) call close(4)
              $4 = 0
              (gdb) detach

              add this to the tutorial
            </aside>
            <h1>Another story</h1><img height="50%" src="./spoon.jpg" border="0">
          </section>

          <section>
            <aside class="notes">
              This seems pretty difficult, but actually it's a fairly straightforward fix.
              One more thing you need to know about before we start
              inodes 
              inodes are files in Linux
              filenames and files are not the same thing
              a filename is a reference to a file
              when you create a file the link count is 1
              When you remove a file, you actually execute unlink
              next slide
            </aside>
            <h1 class="fragment">inodes</h1>
            <pre class="fragment"><code>
            $ stat /lib64/libc.so.6
   File: /lib64/libc.so.6 -> libc-2.29.so
   Size: 12 Blocks: 0 IO Block: 4096 symbolic link
 Device: fd01h/64769d	Inode: 2268443   Links: 1
 Access: (0777/lrwxrwxrwx) Uid:(0/root) Gid:(0/root)
Context: system_u:object_r:lib_t:s0
 Access: 2019-10-24 20:01:01.282015177 -0700
 Modify: 2019-09-04 12:33:47.000000000 -0700
 Change: 2019-09-08 19:57:02.255027798 -0700
  Birth: 2019-09-08 19:57:02.254027799 -0700
            </code></pre>
          </section>

          <section>
            <aside class="notes">
              unlink just reduces the link count by one
              if there's an open filehandle, the file isn't deleted
              we can get the data.
              on the other hand, it can also continue to use space but not be reported in things like du.
            </aside>
            <h1>Unlink</h1>
            <pre class="fragment"><code class="nohighlight">
# man 2 unlink
DESCRIPTION
  unlink() deletes a name from the filesystem.  
  If that name was the last link to a file and
  no processes have the file open, the file is
  deleted and the space it was using is made
  available for reuse.

  If the name was the last link to a file but
  any processes still have the file open, the
  file will remain in existence until the last
  file descriptor referring to it is closed.
            </code></pre>
          </section>
          
          <section>
            <aside class="notes">
              we just want to tell a running process to change filehandles.
              There's a tool to do that.
            </aside>
            <h1 class="fragment">gdb</h1>
            <img class="fragment" src="./archer.png" >
          </section>

          <section>
            <aside class="notes">
              lets look at what we need to do.
            </aside>
            <pre><code class="nohighlight">
# man open
  SYNOPSIS
    #include &lt;sys/types.h&gt;
    #include &lt;sys/stat.h&gt;
    #include &lt;fcntl.h&gt;</code></pre>
            ... /usr/include/fcntl.h
            <pre><code class="nohighlight" data-trim data-noescape>
/* Get the definitions of O_*, F_*, FD_*: all the
numbers and flag bits for `open', `fcntl', et al.  */
#include &lt;bits/fcntl.h&gt;
            </code></pre>
            ... /usr/include/bits/fcntl.h
            <pre><code class="nohighlight">
#define O_RDWR         02
#ifndef O_CREAT
# define O_CREAT     0100 /* Not fcntl.  */
#endif</code></pre>
          </section>
          <section>
            <aside class="notes">
              The dup2 system call is used to duplicate a file descriptor. Since 
            </aside>
            <pre><code class="nohighlight">
# man dup2
int dup2(int oldfd, int newfd);

dup2()
  The dup2() system call performs the same task as dup(),
  but instead of using the lowest-numbered unused file 
  descriptor, it uses the file descriptor number specified
  in newfd.  If the file descriptor newfd  was  previ‐
  ously open, it is silently closed before being reused.
            </code></pre>
          </section>
          <section>
            <aside class="notes">
              solution
              ap gdb.cast
            </aside>
            <h1>&lArr;</h1>
          </section>
        </section>

        <!-- troubleshooting basics -->
        <section>
          <section>
            <h1>Troubleshooting</h1>
            <h2 class="fragment">...finally</h2>
          </section>

          <section>
            <h1>Have a Plan</h1>
            <h2><ul>
                <li><b>What</b> is broken?
                  <h2>
                    <ul>
                      <li>Did it ever work?</li>
                      <li>How do I know when it's fixed?</li>
                    </ul>
                  </h2>
                </li>
                <li>What are the requirements?
                  <h2>
                    <ul>
                      <li>How can I test the requirements?</li>
                    </ul>
                  </h2>
                </li>
                <li><b>When did it last work?</b></li>
              </ul>
            </h2>
          </section>

          <section>
            <h1>Methods</h1>
            <h2>
              <ul>
                <li>Make a backup <i>if possible</i></li>
                <li>
          </section>
        </section>


        <section>
          <h1>Questions?</h1>
          <span class="fragment"><h2>Thank-you</h2></span>
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true }
        ]
      });
    </script>
<!--  <script>
    document.addEventListener("keydown",function(ev) {
      console.log(ev.keyCode);
      if(ev.keyCode == 'Escape') {
        ev.preventDefault();
        return false;
      } else if(ev.keyCode == 'f') {
    document.body.requestFullscreen().then(
      () => {
        const keys = [
          { code: 'Escape' },
          ];
        navigator.requestSystemKeyboardLock(keys);
    });

      }
    })
</script>-->
  </body>
</html>
